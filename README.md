# DesignPattern
设计模式

- strategy 策略模式
- observer 观察者模式
- decorator 装饰者模式
- factory 工厂模式（简单工厂/抽象工厂）
- singleton 单例模式
- command 命令模式
- adapter 适配器模式
- facade 外观模式
- template 模板模式
- iterator 迭代器模式
- composite 组合模式
- state 状态模式
- proxy 代理模式
- bridge 桥接模式
- builder 建造者模式
- chain_of_responsibility 责任链模式
- flyweight 蝇量模式
- interpreter 解释器模式
- mediator 中介者模式
- memento 备忘录模式
- prototype 原型模式
- visitor 访问者模式

#策略模式(Strategy)
###介绍
策略模式： 将算法或操作抽象成`实现共同接口、可以被替换`的类，实现逻辑和具体算法的解耦。

- 将各种行为`抽象成算法`，封装算法为对象； 
- 算法实现`共同接口`，调用者调用时不考虑算法具体实现，调用接口方法即可；
- 调用者可随时替换此算法对象；


###场景
- 多个方法择一使用，且他们会被随时替换；
- 方法没有共性，使用继承会有大量重写，使用接口会有大量重复使用；

###实现
1. 两个算法： 冒泡排序和快速排序；
2. 抽象冒泡排序和快速排序为算法对象，实现算法接口，拥有 used() 被使用方法；
3. 计算器计算时不用理会是什么算法，调用 used() 即可。


---
#观察者模式(Observer)
###介绍
观察者模式：主题`主动向观察者推送`变化，解决观察者对主题对象的依赖。

- 观察者实现`被通知`接口，并在主题上注册，主题只`保存观察者的引用`，不关心观察者的实现；
- 在主题有变化时调用观察者的通知接口来通知已注册的观察者；
- 通知方式有`推`（主题变化时将变化数据推送给观察者）和`拉`（主题只告知变化，观察者主动来拉取数据）

###场景
- 一个主题，多个观察者，主题的任何变动，观察者都要第一时刻得到；
- 观察者获取主题变化困难，定时不及时，轮询消耗大；
- 观察者可以随时停止关注某主题；

###实现
1. 张三和李四是记者，他们需要及时了解城市发生的新闻；
2. 张三和李四在电视台注册了自己的信息；
3. 城市发生了新闻，电视台遍历注册信息，通知了张三和李四；
4. 李四退休了，在电视台注销了自己的信息；
5. 城市又发生了新闻，电视台只通知了张三；


---
#装饰者模式(Decorator)

###介绍
装饰者模式：包装一个对象，在被装饰对象的基础上`添加功能`；

- 装饰者与被装饰对象拥有同一个超类，`装饰者拥有被装饰对象的所有外部接口`，可被调用，外界无法感知调用的是装饰者还是被装饰者；
- 装饰者需要被装饰者作为参数传入，并在装饰者内部，在`被装饰者实现的基础上添加或修改某些功能`后，提供同被装饰者一样的接口；
- 装饰者也可被另一个装饰者装饰，即嵌套装饰。
- 装饰者是一群包装类，由于装饰的复杂性，会多出很多个装饰者小类；


###场景
- 对象需要动态地添加和修改功能；
- 功能改变后不影响原对象的使用

###实现
1. 在商店内，花作为被装饰者对象、红丝带和盒子作为花的装饰者；
2. 花、红丝带、盒子有共同的超类“商品”，他们都能被卖掉；
3. 我们可以在红丝带装饰过花后，再用盒子再包装一次；
4. 包装后的花，顾客买时也不会受到任何影响；

---
#工厂模式(Factory)

###介绍
工厂模式： 顾名思义，工厂模式是`对象的生产器`，解耦用户对具体对象的依赖。

- 实现`依赖倒置`，让用户通过一个"产品工厂"`依赖产品的抽象`，而不是一个具体的产品；
- 简单工厂模式：接收参数并根据参数创建对应类，将对象的实例化和具体使用解耦；
- 抽象工厂模式：将工厂`抽象出多个生产接口`，不同类型的工厂调用生产接口时，生产不同类型的对象；
- 简单工厂常配合抽象工厂一起使用；

###场景
- 根据不同条件需求不同的对象；
- 对象实例化的代码经常需要修改；

###实现
1. 简单工厂：向鞋厂内传入不同的类型（布制），鞋厂会生产出不同类型的鞋子（布鞋）；
2. 抽象工厂：有两座鞋厂：李宁鞋厂、Adidas鞋厂，他们能生产对应各自品牌的鞋子；
3. 搭配使用：向不同的抽象工厂（李宁）传入不同的类型（运动类型），会生产出对应品牌对应类型的鞋子（李宁运动鞋）；

---
#单例模式(Singleton)
###介绍
单例模式：保证同一个类`全局只有一个实例对象`;

- 在第一次实例化后会使用`静态变量保存`实例，后续全局使用此静态变量；
- 一般将构造方法私有化，构造方法添加 final 关键字无法被重写，添加一个类静态方法用于返回此实例；
- 在多线程时应该考虑`并发`问题，防止两次调用都被判定为实例未初始化而重复初始化对象；

###场景
- 全局共享同一个实例对象（数据库连接等）；
- 某一处对此对象的更新全局可见；

###实现
1. 利用 Go 中包的可见性规则来隐藏对象的实例化权限；
2. 使用包变量保存实例对象，获取实例时判断是否已实例化，如为nil，实例化对象并返回，如有值，直接返回值；
3. 待用锁实现 Go routine 并发时的问题；

----
#命令模式(Command)
###介绍
命令模式:将一个`命令封装成对象`，解耦命令的发起者和执行者。

- 命令对象实现`命令接口（excute[、undo]）`，命令发起者实例化命令对象，并传递此对象，并不关心此对象由谁执行；
- 命令执行者只负责调用命令对象的执行方法即可，不关心对象是由谁生成的；
- 与策略模式不同之处：策略模式是通过不同的算法做同一件事情（例如排序），而命令模式则是通过不同的命令做不同的事情；

###场景
- 命令发起者与执行者无法直接接触；
- 命令需要撤销功能，却不易保存命令执行状态信息时；

###实现
1. 指挥官创建了一个“从树下跑到草地上”的命令；
2. 命令被分配给张三执行，张三作为军人，接到命令后不管命令的具体内容，而是直接调用命令的执行接口执行。
3. 指挥官发布了撤销指令，张三又从草地上跑到了树下。

---
#适配器模式(Adapter)
###介绍
适配器模式：包装对象提供一个接口，以`适配调用者`。

- 适配器通过一个中间对象，`封装目标接口`以`适应调用者`调用；
- 调用者调用此适配器，以达到调用目标接口的目的；
- 适配器模式与装饰者模式的不同之处：适配器模式不改变接口的功能，而装饰者会添加或修改原接口功能；

###场景
- 提供的接口与调用者调用的其他的接口都不一致；
- 为一个特殊接口修改调用者的调用方式得不偿失；

###实现
1. 张三是个正常人，他能通过说话直接地表达自己；
2. 李四是个聋哑人，他没法直接表达自己，但他会写字。
3. 笔记本作为一个适配器，用笔记本“包装”了李四之后，当李四需要表达自己想法时，调用笔记本的“表达”功能，笔记本再调用李四“写字”的方法。

---
#外观模式(Facade)
###介绍
外观模式：通过`封装多个复杂的接口`来提供一个`简化接口`来实现一个复杂功能。

- 外观模式是通过封装多个接口来将接口`简单化`；
- 外观模式不会改变原有的多个复杂的单一接口，这些接口依然能被单独调用，只是提供了一个额外的接口；
- 外观模式与适配器模式的不同之处：外观模式是`整合`多个接口并`添加`一个简化接口，适配器是适配一个接口；

###场景
- 实现某一功能需要调用多个复杂接口；
- 经常需要实现此功能，

###实现
1. 正常的冲咖啡步骤是：磨咖啡豆、烧开水、倒开水搅拌咖啡。
2. 我们经常需要直接冲咖啡，而不是使用单一步骤，每次喝咖啡时调用三个方法很麻烦；
3. 封装三个接口，额外提供一个 “冲咖啡” 的方法，需要喝咖啡时只需要调用一次冲咖啡方法即可。

---
#模板模式(Template)
###介绍
模板模式：模板模式在`抽象类或父类`中抽象出`算法步骤`作为模板，模板的具体细节推迟到子类实现。

- 模板模式在父类或抽象类中定义一个`算法的骨架`，并在父类或抽象类中实现共同的部分，各个不同的步骤由不同的子类分别实现；
- 模板板式在父类的算法步骤中定义`勾子(hook)`，在子类中判断并定义一些不是非通用步骤；
- 模板模式与策略模式的不同之处在于，策略模式是针对多个不同的算法，而模板模式是针对一个算法的不同步骤，在模板模式中，只有一个算法；


###场景
- 多个算法有多个共同之处，但某些步骤略微不同；
- 各子类步骤顺序一致，但步骤的具体实现有所不同时；

###实现
1. 有发邮件和发短信两种通讯方式；
2. 他们都需要获取目标信息、格式化正文、填写发送方信息，但实现不同；
3. 在信息类中抽象出三个步骤，具体的处理方式由两种通讯方式各自实现；
4. 发送信息时调用信息类中的发送方法，发送方法会按照顺序自动调用对应的步骤；


---
#迭代器模式(Iterator)
###介绍
迭代器模式：迭代器模式允许调用者在`不知道类内部实现`的情况下`遍历类元素`。

- 迭代器接口常用方法有 `length(),next(),previous(),remove()`等；
- 各类在内部实现迭代器接口，用对应的方法操作元素；
- 调用者不考虑类内部实现，调用迭代器接口即可；

###场景
- 类使用不同的数据结构存储数据；
- 需要对不同的数据类型进行遍历等操作；

###实现
1. 使用 slice 存储一列战马，使用 map 存储一列士兵；
2. 战马和士兵结构都实现了迭代器接口；
3. 获取战马数和士兵数，遍历战马和士兵，调用迭代器接口即可；


---
#组合模式(Composite)
###介绍
组合器模式：使用一种`组件抽象`来同时表达`集合与元素`，使用统一的接口来管理集合和元素。

- 组合模式通常为`树结构`，父结点和子节点具有同样的抽象和接口；
- 在操作集合时，会`同时操作集合所属的具体元素`；
- 通常给组合模式添加一个迭代器来完成组合结构的迭代；

###场景
- 管理的多个对象构成树型层级结构；
- 操作高层级的对象时，需要同时其所属的下级对象，如界面窗口等；

###实现
1. 将军、队长、士兵构成树型层级结构，且他们都是战士，拥有战斗方法；
2. 每位战士都保存着自己的下级名单，没有下级时忽略；
3. 每个人在战斗时，都会率领着下级战斗；

---
#状态模式(State)
###介绍
状态模式：状态模式抽象出一个`事物的状态`作为类，解耦事物和不同状态下的行为；

- 状态模式通过替换状态对象作为状态转换的方式；
- 状态对象实现根据状态动作的接口，可以根据不同的`动作做出对应`的反应；
- 状态模式与策略模式的实现相似，但状态模式是对类内部状态作出改变，而策略模式是针对算法封装；

###场景
- 事物有多种状态，且可以相互转换；
- 事物多种状态下对同一动作做出的行为不同；

###实现
1. 植物有 幼苗、开花和成熟 三种状态，且它们会通过浇水和收获的动作进行相互转换；
2. 幼苗和开花时不能收获，只能浇水，成熟状态只能收获，不需要再浇水；
3. 定义三种状态，和它们对不同动作时的行为，植物通过三种对象的替换来进行状态转换；


---
#代理模式(Proxy)
###介绍
代理模式：给对象提供一个代理，由代理对象控制对原对象的调用；

- 代理模式为一个对象（通常是大对象或无法复制的对象）`创建另外一个类作为其访问的接口`，所有对真实对象的请求都`通过代理对象`完成；
- 代理对象可以`控制用户对真实对象的访问权限`，也可以在访问真实对象时附加功能;
- 代理模式可被用作：远程代理，虚拟代理，安全代理，指针引用，延迟加载；

###场景
- 对象无法被直接访问时；
- 对象过大，初始化较慢；
- 对象不必要立刻初始化，可使用默认值代替；

###实现
1. 小明给暗恋对象写了一封信，在等回信；
2. 邮递员是个非常忙的人，来不及去收取回信；
3. 小明好声好气向邮递员要回信时，邮递员都推拖说自己要去取；
4. 小明发怒了，邮递员终于抽时间去取了信给小明；
5. 此信中邮递员就是代理模式中的代理，他实现了懒加载。
6. 回信内容见源码：）


---
#桥接模式(Bridge)
###介绍
桥接模式：将事务的`多个维度`都抽象出来以`解耦抽象与实际`之间的绑定关系，使抽象和实际向着不同维度改变；

- 桥接模式通过对象的组合来解决事物的多维度变化问题，以替代多继承的不灵活；
- 桥接模式可以轻易在多维度上拓展，而不改变原有模式；
- 桥接模式与策略模式的不同之处：策略模式是针对一个不变的主题替换抽象算法，而桥接模式是策略模式的高维度状态，它的主题也可能会被替换；

###场景
- 某事物在多个维度上都有变化；
- 无法使用多继承或使用多继承会很不灵活；

###实现
1. 作画时可以使用铅笔和圆珠笔等不同的笔，也可以在宣纸或普通A4纸；
2. 抽象出笔和纸两种对象；
3. 自由组合笔和纸进行作画；

---
#建造者模式(Builder)
###介绍
建造者模式：建造者模式`分离创建复杂对象的过程和细节`，使得同样的创建过程能创建不同的对象。

- 建造者模式将创建对象部件的`一般过程抽象出接口`，而由不同的建造者类实现具体的接口，实现过程的步骤；
- 通过建造者，调用者不用考虑对象创建过程的细节，且建造者也可以被灵活替换；
- 与模板模式的区别：建造者模式使用类的组合进行对象的创建，而模板模式使用类的继承实现对象的具体构造；
- 与工厂模式的区别：工厂模式会返回一个具体类，而建造者模式会建造出一个由多个类组装而成的完整类；

###场景
- 对象的创建包含其他对象为类元素，创建过程复杂；
- 多个复杂对象的创建过程具有高度相似性；

###实现
1. 中国式建筑有金色屋顶和红色大门，而意式建筑有圆项和白色大门；
2. 中国建筑师和意式建筑师分别擅长建造不同类型的建筑；
3. 我们在盖不同类型的房子时先创建一个建筑师，再用建筑师去创建对应风格的房子；